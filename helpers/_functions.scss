// | tint ====================================================================\\

/// Slightly lighten a color
/// @author unknow
/// @access public
/// @param {Color} $color - color to tint
/// @param {Number} $percentage - percentage of `$color` in returned color
/// @return {Color}
@function tint($color, $percentage) {
  @return mix($color, #fff, $percentage);
}


// | shade ================================================================== \\

/// Slightly darken a color
/// @author unknow
/// @access public
/// @param {Color} $color - color to shade
/// @param {Number} $percentage - percentage of `$color` in returned color
/// @return {Color}
@function shade($color, $percentage) {
  @return mix(#000, $color, $percentage);
}

// | map deep get ============================================================\\

/// Map deep get
/// @author Hugo Giraudel
/// @access public
/// @param {Map} $map - Map
/// @param {Arglist} $keys - Key chain
/// @return {*} - Desired value
@function get($map, $keys...) {
  $cache: $map;
    @each $key in $keys {
      @if type-of($map) == map {
        $map: map-get($map, $key);
      }@else {
        @error $map ' : is not a map';
      }
    }
    @return $map;
}
@function G($map, $keys...) {
  @return get($map, $keys...);
}
// | map deep set =========================================================== \\

/// Deep set function to set a value in nested maps
/// @author Hugo Giraudel
/// @access public
/// @param {Map} $map - Map
/// @param {List} $keys -  Key chaine
/// @param {*} $value - Value to assign
/// @return {Map} map with the new key and her value
@function set($map, $keys, $value) {
  $maps: ($map,);
  $result: null;

  // If the last key is a map already
  // Warn the user we will be overriding it with $value
  @if type-of(nth($keys, -1)) == 'map' {
    @warn "The last key you specified is a map; it will be overrided with `#{$value}`.";
  }

  // If $keys is a single key
  // Just merge and return
  @if length($keys) == 1 {
    @return map-merge($map, ($keys: $value));
  }

  // Loop from the first to the second to last key from $keys
  // Store the associated map to this key in the $maps list
  // If the key doesn't exist, throw an error
  @for $i from 1 through length($keys) - 1 {
    $current-key: nth($keys, $i);
    $current-map: nth($maps, -1);
    $current-get: map-get($current-map, $current-key);
    @if $current-get == null {
      @error "Key `#{$current-key}` doesn't exist at current level in map.";
    }
    $maps: append($maps, $current-get);
  }

  // Loop from the last map to the first one
  // Merge it with the previous one
  @for $i from length($maps) through 1 {
    $current-map: nth($maps, $i);
    $current-key: nth($keys, $i);
    $current-val: if($i == length($maps), $value, $result);
    $result: map-merge($current-map, ($current-key: $current-val));
  }

  // Return result
  @return $result;
}

@function S($map, $keys, $value) {
  @return set($map, $keys, $value);
}

// | map deep delete ======================================================== \\

@function delete($map, $keys, $count: 1, $length: false) {
  @if $length == false {
    $length: length($keys);
  }
  $result: ();
  $new-keys: ();
  @if length($keys) == 1 {
    @if type-of($map) != map {
      // @error $map;
    }
    @return map-remove($map, nth($keys, 1));
  }@else {
    @if length($keys) > 1 {
      @for $i from 2 through length($keys) {
        $new-keys: join($new-keys, nth($keys, $i), comma);
      }
    }
    @each $k, $v in $map {
      @if $k != nth($keys, 1) {
        $result: map-merge($result, ($k:$v));
      }@else if length($keys) == 1 and $k == nth($keys, 1) and $length == $count{
        $result: map-merge($result, map-remove($v));
      }@else {
        $result: map-merge($result, ($k: delete($v, $new-keys, $count: $count + 1, $length: $length)));
      }
    }
  }
  @return $result;
}

@function D($map, $keys, $count: 1, $length: false) {
  @return delete($map, $keys, $count, $length);
}

// | list delete ============================================================ \\

@function remove($list, $value, $recursive: false) {
  $result: ();

  @for $i from 1 through length($list) {
    @if type-of(nth($list, $i)) == list and $recursive {
      $result: append($result, remove(nth($list, $i), $value, $recursive));
    } @else if nth($list, $i) != $value {
      $result: append($result, nth($list, $i));
    }
  }

  @return $result;
}

$BPS: () !global;
$this: () !global;

// | breakpoints ============================================================ \\

@mixin BPS($max, $min: false) {
  $max: if($max, $max - 0.05px, $max);
  @if $max != false and $min != false {
    @media (max-width: $max) and (min-width: $min) {@content;}
  }@else if $max != false {
    @media (max-width: $max) {@content;}
  }@else if $min != false {
    @media (min-width: $min) {@content;}
  }@else { @content; }
}

// | this =================================================================== \\

@function this($keys...) {
  @return G($this, $keys...);
}

// | get breakpoint value =================================================== \\

@function Gbp($var-name, $global: true) {
  @if type-of($var-name) == list {
    $result: false;
    @each $name in $var-name {
      @if $result == false {
        @if G($this, 'values', $name) != null or (G($this, 'global', $name) != null and $global == true) {
          $result: true;
        }@else {
          $result: false;
        }
      }
    }
    @return $result;
  }@else {
    @return if(G($this, 'values', $var-name) != null, G($this, 'values', $var-name), if(G($this, 'global', $var-name) != null and $global == true, G($this, 'global', $var-name), null));
  }
}

// | set breakpoint value =================================================== \\

@function Sbp($var-name, $value) {
  $result: ();
  $breakpoint: ();
  $global: ();
  @if this('breakpoint', 'values') == map {
    $breakpoint: map-merge(this('breakpoint'), ('values': map-merge(this('breakpoint', 'values'), ($var-name: $value))));
  }@else {
    $breakpoint: map-merge(this('breakpoint'), ('values': ($var-name: $value)));
  }

  @if this('global') {
    $global: map-merge(this('global'), ($var-name: $value));
  }

  $result: S($this, 'breakpoint', $breakpoint);
  $result: S($this, 'global', $global);

  @return $result;
}

// | add breakpoints vars (loop) ============================================ \\

@function add-bp-vars-loop($breakpoints, $new, $var-name) {
  $new: map-merge(('max':  false, 'min': false), $new);
  $this: $new !global;
  $global: if(this('max') == false and this('min') == false, ($var-name: this('value')), null);
  $value: G($new, 'value');
  $new-breakpoint: D($new, 'value');
  $finded: false;
  $values: ();
  $temp: ();
  @each $breakpoint in $breakpoints {
    $this: $breakpoint !global;
    @if this('global') and $global {
      $global: map-merge(this('global'), $global);
    }@else if this('global') {
      $global: this('global');
    }
  }
  @each $breakpoint in $breakpoints {
    $this: $breakpoint !global;
    $breakpoint: map-merge($breakpoint, ('global': $global));
    @if this('breakpoint') == $new-breakpoint {
      $finded: true;
      $breakpoint: map-merge($breakpoint, ('values': (S(this('values'), $var-name, $value))));
    }
    $temp: append($temp, $breakpoint);
  }
  $breakpoints: $temp;
  @if $finded == false {
    $breakpoints: append($breakpoints, ('breakpoint': $new-breakpoint, 'values': ($var-name: $value), 'global': $global));
  }
  @return $breakpoints;
}

// | add breakpoints vars =================================================== \\

@function add-bp-vars($map, $name, $object: true, $object-child: false) {
  $breakpoints: ();
  @if $object {
    @each $instance-name, $instance in $map {
      $breakpoints: S($breakpoints, $instance-name, add-bp-vars($instance, $instance-name, false, true));
    }
  }@else {
    @each $var-name, $properties in $map {
      @if type-of($properties) == map { // if there is only one breakpoint
        $breakpoints: add-bp-vars-loop($breakpoints, $properties, $var-name);
      }@else if type-of($properties) == list { // if there is various breakpoints
        @each $breakpoint in $properties {
          $breakpoint: if(type-of($breakpoint) == map, $breakpoint, ('value': $breakpoint));
          $breakpoints: add-bp-vars-loop($breakpoints,  $breakpoint, $var-name);
        }
      }@else { // if there is no breakpoint
        $breakpoints: add-bp-vars-loop($breakpoints, ('value': $properties,), $var-name);
      }
    }
  }
  @if $object-child {
    @return $breakpoints;
  }@else{
    @return S($BPS, $name, $breakpoints);
  }
}
